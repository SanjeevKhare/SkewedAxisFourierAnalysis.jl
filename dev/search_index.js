var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SkewedAxisFourierAnalysis]","category":"page"},{"location":"api/#SkewedAxisFourierAnalysis.build_sheared_function_from_sinousoids-Union{Tuple{T2}, Tuple{T1}, Tuple{T}, Tuple{AbstractArray{Tuple{T, T, T1, T1}}, AbstractArray{T1}, AbstractArray{T1}, T2}} where {T, T1<:Real, T2<:Real}","page":"API","title":"SkewedAxisFourierAnalysis.build_sheared_function_from_sinousoids","text":"build_function_from_sinousoids(opdata, xx, yy, θ)\n\nBuilds the function from the sinousoids, on x and y axis skewed at an angle θ. The function is evaluated at the points xx and yy, which are the meshgrid points where you want the function to be evaluated.\n\nArguments\n\nopdata: The sinousoids data. It is a vector of tuples, where each tuple is (i, j, mag, ang), where i and j are the harmonic indices, mag is the magnitude of the harmonic, and ang is the phase of the harmonic.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.convert_image_to_data-Union{Tuple{T2}, Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T2}, Float64, Float64, Float64}} where {T, T2}","page":"API","title":"SkewedAxisFourierAnalysis.convert_image_to_data","text":"convert_image_to_data(img, cb, decimation_factor, lowerlimit, upperlimit)\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.create_image_from_data-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Real","page":"API","title":"SkewedAxisFourierAnalysis.create_image_from_data","text":"create_image_from_data(fval, custom_color_map)\n\nCreate an image from 2D data fval using the custom color map custom_color_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.crop_transparent_border_of_image-Union{Tuple{Array{ColorTypes.RGBA{T}, 2}}, Tuple{T}} where T<:Number","page":"API","title":"SkewedAxisFourierAnalysis.crop_transparent_border_of_image","text":"crop_transparent_border_of_image(warped_img)\n\nCrop the transparent border of the image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.extract_dominant_harmonics-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Real","page":"API","title":"SkewedAxisFourierAnalysis.extract_dominant_harmonics","text":"extract_dominant_harmonics(image_data, threshold=0.005)\n\nExtract the dominant harmonics from the image data (2D data). The threshold is used to determine the high power mask. The frequencies are extracted from the high power mask and centered around the zero frequency. frequencies and their Fourier coefficients are returned.\n\nArguments\n\nimage_data: The image data to be analyzed.\nthreshold=0.005: The threshold for high power.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.fft_power_analysis-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Real","page":"API","title":"SkewedAxisFourierAnalysis.fft_power_analysis","text":"fft_power_analysis(image_data, threshold=0.005)\n\nPerform a power analysis on the Fourier transform of the image data. Based on the threshold, the high power mask is generated. Total power spectral density of frequencies in high power mask is greater than the threshold. \n\nArguments\n\nimage_data: The image data to be analyzed.\nthreshold=0.005: The threshold for high power.\n\nReturn value\n\nhigh_power_mask: The mask for high power.\nimage_fft_raw: The raw Fourier transform of the image data.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.filter_principal_frequencies_for_fft_of_real_data-Tuple{Vector{Tuple{Int64, Int64, ComplexF64}}}","page":"API","title":"SkewedAxisFourierAnalysis.filter_principal_frequencies_for_fft_of_real_data","text":"filter_principal_frequencies_for_fft_of_real_data(sinousoids)\n\nFilter the principal frequencies for the FFT of real data. As FFT of real data have the property      F(omega) = conj(F(-omega)) We can filter the principal frequencies for the FFT of real data and still fully reconstruct the image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.findnearest_value_index-Union{Tuple{F}, Tuple{T}, Tuple{F, AbstractArray{T}, T}} where {T, F<:Function}","page":"API","title":"SkewedAxisFourierAnalysis.findnearest_value_index","text":"findnearest_value_index(f::F, x::AbstractArray{T}, x1::T) where {T,F<:Function}\n\nFind the index of the nearest value in the array x to the value x1 using the function f to measure the distance between these two points.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.map_image_to_data-Union{Tuple{T1}, Tuple{T}, Tuple{Array{ColorTypes.RGB{T}, 2}, Array{ColorTypes.RGB{T}, 1}, T1, T1}} where {T, T1<:Float64}","page":"API","title":"SkewedAxisFourierAnalysis.map_image_to_data","text":"map_image_to_data(img::Matrix{RGB{T}}, cb_line::Vector{RGB{T}}, lowerlimit, upperlimit)\n\nMap a scientific image to a data array using a colorbar line, and lower and upper limits of the colorbar.\n\nArguments\n\nimg::Matrix{RGB{T}}: The scientific image to be mapped to data. Element type is RGB{T}.\ncb_line::Vector{RGB{T}}: The colorbar line. Element type is RGB{T}.\nlowerlimit: The lower limit of the colorbar.\nupperlimit: The upper limit of the colorbar.\n\njulia     imagedata = mapimagetodata(img, cb_line, lowerlimit, upperlimit)\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.rgb_to_rgba-Union{Tuple{Array{ColorTypes.RGB{T}, 2}}, Tuple{T}} where T<:Number","page":"API","title":"SkewedAxisFourierAnalysis.rgb_to_rgba","text":"rgb_to_rgba(img::Array{RGB{T},2}) where {T<:Number}\n\nConvert an RGB image to an RGBA image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.rgba_to_rgb-Union{Tuple{Array{ColorTypes.RGBA{T}, 2}}, Tuple{T}} where T<:Number","page":"API","title":"SkewedAxisFourierAnalysis.rgba_to_rgb","text":"rgba_to_rgb(img::Array{RGBA{T},2}) where {T<:Number}\n\nConvert an RGBA image to an RGB image.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.shear_image-Tuple{Any, Any}","page":"API","title":"SkewedAxisFourierAnalysis.shear_image","text":"shear_image(img, θ)\n\nShear the image at an angle θ.\n\nArguments\n\nimg: The image to be sheared.\nθ: The angle in degrees at which the image is to be sheared.\n\n\n\n\n\n","category":"method"},{"location":"api/#SkewedAxisFourierAnalysis.write_opdata_to_file-Tuple{Any, Any}","page":"API","title":"SkewedAxisFourierAnalysis.write_opdata_to_file","text":"write_opdata_to_file(opdata, sine_filename)\n\nWrite the opdata to a file with the format i, j, mag, ang. The last line is the DC component.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SkewedAxisFourierAnalysis","category":"page"},{"location":"#SkewedAxisFourierAnalysis","page":"Home","title":"SkewedAxisFourierAnalysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SkewedAxisFourierAnalysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the tutorial to see how to use this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#introduction","page":"Tutotial","title":"Introduction","text":"","category":"section"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"We will use the package to analyze the sheared axis crystal image.","category":"page"},{"location":"tutorial/#tutorial","page":"Tutotial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"This Tutorial will guide you through the process of using the package.","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"We will take sheared axis crystal image. Reshape it. Convert it into data.\nExtract the dominant harmonics.\nFilter the principal frequencies.\nReconstruct the image from the data.","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"using Images, ColorSchemes\nimport SkewedAxisFourierAnalysis as FA\n\n# We are going to use this function to check the reconstruction of the image\nfunction check_reconstruction(opdata, θ, custom_color_map)\n    x, y = range(0, 4, length=600), range(0, 4, length=600)\n    xx = ones(length(y)) * x'\n    yy = repeat(y, 1, length(x))\n    sol_data = FA.build_sheared_function_from_sinousoids(opdata, xx, yy, θ)\n    return FA.create_image_from_data(sol_data, custom_color_map), sol_data\nend\n\n# Load the image and the colorbar\nimg_raw = load(\"../assets/CrCl3_sheared.png\")\ncb_path = \"../assets/crcl3_cb.png\"\n\n# The file where the harmonics data will be stored\nsine_filename = \"CrCl3_sin_dict.txt\"","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"Transform image and crop the transparent border","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"warped_img = FA.shear_image(img_raw, 30)\ncropped_img = FA.crop_transparent_border_of_image(warped_img)\nmosaicview(img_raw, cropped_img, nrow=1, ncol=2)","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"Now that image is in orthogonal coordinates, we can convert it to data. Since it is color image, we will have to approximate the perception of each pixel to a single value.","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"# Read and interpret the colorbar so that we can map colors to values\ncb = load(cb_path);\nif eltype(cb) == RGBA{N0f8}\n    cb = FA.rgba_to_rgb(cb)\nend\n\n# Also create a custom color map based on the color bar,\n# if you want to recreate the image from data\ncb_line = cb[:, div(size(cb, 2), 2)]\ncustom_color_map = ColorScheme(reverse(cb_line));\n\n# Convert the image to data\nimg_jpg = imresize(FA.rgba_to_rgb(cropped_img), ratio=0.05)\nimage_data = FA.map_image_to_data(img_jpg, cb_line, -2.22, 1.05)\nFA.create_image_from_data(image_data, custom_color_map)\n\n# Extract Harmonics and package harmonics data to file\nsinousoids = FA.extract_dominant_harmonics(image_data, 0.001)\nopdata  = FA.filter_principal_frequencies_for_fft_of_real_data(sinousoids)\nFA.write_opdata_to_file(opdata, sine_filename)\n\n# See how the image is reconstructed\nsol_img, sol_data = check_reconstruction(opdata, 120, custom_color_map)\nsol_img","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"","category":"page"},{"location":"tutorial/","page":"Tutotial","title":"Tutotial","text":"This page was generated using Literate.jl.","category":"page"}]
}
